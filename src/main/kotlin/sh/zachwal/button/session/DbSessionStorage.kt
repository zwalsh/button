package sh.zachwal.button.session

import io.ktor.server.sessions.SessionStorage
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import sh.zachwal.button.db.dao.SessionDAO
import sh.zachwal.button.db.jdbi.Session
import java.time.Instant

/**
 * Database-backed session storage implementation that prefixes session IDs to prevent collisions.
 *
 * After upgrading to Ktor 2.0, the framework can reuse the same session ID for different session types
 * (e.g., USER_SESSION and CONTACT_SESSION). This class prevents session data from being overwritten by
 * prefixing each session ID with a unique identifier before storing it in the database.
 *
 * For example, if Ktor generates session ID "abc123" for both a user session and a contact session,
 * this class will store them as "USER_SESSION_abc123" and "CONTACT_SESSION_abc123" respectively,
 * allowing both sessions to coexist without trampling each other.
 *
 * @param sessionDAO The DAO for database operations on sessions
 * @param sessionPrefix A unique prefix for this session type (e.g., "USER_SESSION" or "CONTACT_SESSION")
 */
class DbSessionStorage constructor(
    private val sessionDAO: SessionDAO,
    private val sessionPrefix: String
) : SessionStorage {
    private val logger = LoggerFactory.getLogger(DbSessionStorage::class.java)

    /**
     * Converts a Ktor session ID to a database-safe ID by adding the session prefix.
     *
     * @param id The session ID generated by Ktor
     * @return The prefixed ID to use in database operations
     */
    private fun dbId(id: String) = "${sessionPrefix}_$id"

    override suspend fun invalidate(id: String) {
        logger.info("Clearing $id")
        withContext(Dispatchers.IO) {
            sessionDAO.deleteSession(dbId(id))
        }
    }

    override suspend fun read(id: String): String {
        logger.info("Reading session ${id + sessionPrefix}")
        return withContext(Dispatchers.IO) {
            val bytes = sessionDAO.getById(dbId(id))?.data
                ?: throw NoSuchElementException("No session with id $id")
            bytes.decodeToString().also {
                logger.info("Got $it")
            }
        }
    }

    override suspend fun write(id: String, value: String) {
        // Note that this function is called every time the session is used.
        logger.info("Writing ${id + sessionPrefix} as $value")
        withContext(Dispatchers.IO) {
            val session = Session(
                id = dbId(id),
                data = value.encodeToByteArray(),
                // CONTACT_SESSION_LENGTH is the longer of the two. Set the db expiration to the longer one as a session
                // is only valid if the `bytes` contains an expiration time that hasn't passed, and the row is still
                // present in the database (i.e. hasn't been cleaned up by SessionCleanupTask).
                expiration = Instant.now().plus(CONTACT_SESSION_LENGTH)
            )
            sessionDAO.createOrUpdateSession(session)
        }
    }
}
