package sh.zachwal.button.session

import io.ktor.server.sessions.SessionStorage
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import sh.zachwal.button.db.dao.SessionDAO
import sh.zachwal.button.db.jdbi.Session
import java.time.Instant

/**
 * Database-backed session storage implementation that prefixes session IDs to prevent collisions.
 *
 * @param sessionDAO The DAO for database operations on sessions
 * @param sessionPrefix A unique prefix for this session type (e.g., "USER_SESSION" or "CONTACT_SESSION")
 */
class DbSessionStorage(
    private val sessionDAO: SessionDAO,
    private val sessionPrefix: String
) : SessionStorage {
    private val logger = LoggerFactory.getLogger(DbSessionStorage::class.java)

    /**
     * Converts a Ktor session ID to a database-safe ID by adding the session prefix.
     *
     * @param id The session ID generated by Ktor
     * @return The prefixed ID to use in database operations
     */
    private fun dbId(id: String) = "${sessionPrefix}_$id"

    override suspend fun invalidate(id: String) {
        logger.debug("Clearing $id")
        withContext(Dispatchers.IO) {
            sessionDAO.deleteSession(dbId(id))
        }
    }

    override suspend fun read(id: String): String {
        logger.debug("Reading session ${dbId(id)}")
        return withContext(Dispatchers.IO) {
            val bytes = sessionDAO.getById(dbId(id))?.data
                ?: throw NoSuchElementException("No session with id ${dbId(id)}")
            bytes.decodeToString().also {
                logger.debug("Got $it")
            }
        }
    }

    override suspend fun write(id: String, value: String) {
        // Note that this function is called every time the session is used.
        logger.debug("Writing ${dbId(id)} as $value")
        withContext(Dispatchers.IO) {
            val session = Session(
                id = dbId(id),
                data = value.encodeToByteArray(),
                // CONTACT_SESSION_LENGTH is the longer of the two. Set the db expiration to the longer one as a session
                // is only valid if the `bytes` contains an expiration time that hasn't passed, and the row is still
                // present in the database (i.e. hasn't been cleaned up by SessionCleanupTask).
                expiration = Instant.now().plus(CONTACT_SESSION_LENGTH)
            )
            sessionDAO.createOrUpdateSession(session)
        }
    }
}
