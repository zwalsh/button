Migrating from 1.6.x to 2.0.x﻿
Edit pageLast modified: 20 October 2025
This guide provides instructions on how to migrate your Ktor application from the 1.6.x version to 2.0.x.

Ktor Server﻿
Server code is moved to the 'io.ktor.server.*' package﻿
To unify and better distinguish the server and client APIs, server code is moved to the io.ktor.server.* package (KTOR-2865). This means that you need to update dependencies for and imports in your application, as shown below.

Dependencies﻿
Subsystem

1.6.x

2.0.0

Locations

io.ktor:ktor-locations

io.ktor:ktor-server-locations

Webjars

io.ktor:ktor-webjars

io.ktor:ktor-server-webjars

AutoHeadResponse

io.ktor:ktor-server-core

io.ktor:ktor-server-auto-head-response

StatusPages

io.ktor:ktor-server-core

io.ktor:ktor-server-status-pages

CallId

io.ktor:ktor-server-core

io.ktor:ktor-server-call-id

DoubleReceive

io.ktor:ktor-server-core

io.ktor:ktor-server-double-receive

HTML DSL

io.ktor:ktor-html-builder

io.ktor:ktor-server-html-builder

FreeMarker

io.ktor:ktor-freemarker

io.ktor:ktor-server-freemarker

Velocity

io.ktor:ktor-velocity

io.ktor:ktor-server-velocity

Mustache

io.ktor:ktor-mustache

io.ktor:ktor-server-mustache

Thymeleaf

io.ktor:ktor-thymeleaf

io.ktor:ktor-server-thymeleaf

Pebble

io.ktor:ktor-pebble

io.ktor:ktor-server-pebble

kotlinx.serialization

io.ktor:ktor-serialization

io.ktor:ktor-server-content-negotiation, io.ktor:ktor-serialization-kotlinx-json

Gson

io.ktor:ktor-gson

io.ktor:ktor-server-content-negotiation, io.ktor:ktor-serialization-gson

Jackson

io.ktor:ktor-jackson

io.ktor:ktor-server-content-negotiation, io.ktor:ktor-serialization-jackson

Authentication

io.ktor:ktor-auth

io.ktor:ktor-server-auth

JWT authentication

io.ktor:ktor-auth-jwt

io.ktor:ktor-server-auth-jwt

LDAP authentication

io.ktor:ktor-auth-ldap

io.ktor:ktor-server-auth-ldap

DataConversion

io.ktor:ktor-server-core

io.ktor:ktor-server-data-conversion

DefaultHeaders

io.ktor:ktor-server-core

io.ktor:ktor-server-default-headers

Compression

io.ktor:ktor-server-core

io.ktor:ktor-server-compression

CachingHeaders

io.ktor:ktor-server-core

io.ktor:ktor-server-caching-headers

ConditionalHeaders

io.ktor:ktor-server-core

io.ktor:ktor-server-conditional-headers

CORS

io.ktor:ktor-server-core

io.ktor:ktor-server-cors

Forwarded headers

io.ktor:ktor-server-core

io.ktor:ktor-server-forwarded-header

HSTS

io.ktor:ktor-server-core

io.ktor:ktor-server-hsts

HttpsRedirect

io.ktor:ktor-server-core

io.ktor:ktor-server-http-redirect

PartialContent

io.ktor:ktor-server-core

io.ktor:ktor-server-partial-content

WebSockets

io.ktor:ktor-websockets

io.ktor:ktor-server-websockets

CallLogging

io.ktor:ktor-server-core

io.ktor:ktor-server-call-logging

Micrometer metric

io.ktor:ktor-metrics-micrometer

io.ktor:ktor-server-metrics-micrometer

Dropwizard metrics

io.ktor:ktor-metrics

io.ktor:ktor-server-metrics

Sessions

io.ktor:ktor-server-core

io.ktor:ktor-server-sessions

To add all plugins at once, you can use the io.ktor:ktor-server artifact.

Imports﻿
Subsystem

1.6.x

2.0.0

Application

import io.ktor.application.*

import io.ktor.server.application.*

Configuration

import io.ktor.config.*

import io.ktor.server.config.*

Routing

import io.ktor.routing.*

import io.ktor.server.routing.*

AutoHeadResponse

import io.ktor.features.*

import io.ktor.server.plugins.autohead.*

StatusPages

import io.ktor.features.*

import io.ktor.server.plugins.statuspages.*

CallId

import io.ktor.features.*

import io.ktor.server.plugins.callid.*

DoubleReceive

import io.ktor.features.*

import io.ktor.server.plugins.doublereceive.*

Requests

import io.ktor.request.*

import io.ktor.server.request.*

Responses

import io.ktor.response.*

import io.ktor.server.response.*

Plugins

import io.ktor.features.*

import io.ktor.server.plugins.*

Locations

import io.ktor.locations.*

import io.ktor.server.locations.*

Static content

import io.ktor.http.content.*

import io.ktor.server.http.content.*

HTML DSL

import io.ktor.html.*

import io.ktor.server.html.*

FreeMarker

import io.ktor.freemarker.*

import io.ktor.server.freemarker.*

Velocity

import io.ktor.velocity.*

import io.ktor.server.velocity.*

Mustache

import io.ktor.mustache.*

import io.ktor.server.mustache.*

Thymeleaf

import io.ktor.thymeleaf.*

import io.ktor.server.thymeleaf.*

Pebble

import io.ktor.pebble.*

import io.ktor.server.pebble.*

ContentNegotiation

import io.ktor.features.*

import io.ktor.server.plugins.contentnegotiation.*

kotlinx.serialization

import io.ktor.serialization.*

import io.ktor.serialization.kotlinx.json.*

Gson

import io.ktor.gson.*

import io.ktor.serialization.gson.*

Jackson

import io.ktor.jackson.*

import io.ktor.serialization.jackson.*

Authentication

import io.ktor.auth.*

import io.ktor.server.auth.*

JWT authentication

import io.ktor.auth.jwt.*

import io.ktor.server.auth.jwt.*

LDAP authentication

import io.ktor.auth.ldap.*

import io.ktor.server.auth.ldap.*

Sessions

import io.ktor.sessions.*

import io.ktor.server.sessions.*

DefaultHeaders

import io.ktor.features.*

import io.ktor.server.plugins.defaultheaders.*

Compression

import io.ktor.features.*

import io.ktor.server.plugins.compression.*

CachingHeaders

import io.ktor.features.*

import io.ktor.server.plugins.cachingheaders.*

ConditionalHeaders

import io.ktor.features.*

import io.ktor.server.plugins.conditionalheaders.*

CORS

import io.ktor.features.*

import io.ktor.server.plugins.cors.*

Forwarded headers

import io.ktor.features.*

import io.ktor.server.plugins.forwardedheaders.*

HSTS

import io.ktor.features.*

import io.ktor.server.plugins.hsts.*

HttpsRedirect

import io.ktor.features.*

import io.ktor.server.plugins.httpsredirect.*

PartialContent

import io.ktor.features.*

import io.ktor.server.plugins.partialcontent.*

WebSockets

import io.ktor.websocket.*

import io.ktor.server.websocket.*

CallLogging

import io.ktor.features.*

import io.ktor.server.plugins.callloging.*

Micrometer metric

import io.ktor.metrics.micrometer.*

import io.ktor.server.metrics.micrometer.*

Dropwizard metrics

import io.ktor.metrics.dropwizard.*

import io.ktor.server.metrics.dropwizard.*

WebSockets code is moved to the 'websockets' package﻿
WebSockets code is moved from http-cio to the websockets package. This requires updating imports as follows:

1.6.x

2.0.0

import io.ktor.http.cio.websocket.*

import io.ktor.websocket.*

Note that this change also affects the client.

Feature is renamed to Plugin﻿
In Ktor 2.0.0, Feature is renamed to Plugin to better describe functionality that intercepts the request/response pipeline (KTOR-2326). This affects the entire Ktor API and requires updating your application as described below.

Imports﻿
Installing any plugin requires updating imports and also depends on moving server code to the io.ktor.server.* package:

1.6.x

2.0.0

import io.ktor.features.*

import io.ktor.server.plugins.*

Custom plugins﻿
Renaming Feature to Plugin introduces the following changes for API related to custom plugins:

The ApplicationFeature interface is renamed to BaseApplicationPlugin.

The Features pipeline phase is renamed to Plugins.

Note that starting with v2.0.0, Ktor provides the new API for creating custom plugins. In general, this API doesn't require an understanding of internal Ktor concepts, such as pipelines, phases, and so on. Instead, you have access to different stages of handling requests and responses using various handlers, such as onCall, onCallReceive, onCallRespond, and so on. You can learn how pipeline phases map to handlers in a new API from this section: Mapping of pipeline phases to new API handlers.

Content negotiation and serialization﻿
Content negotiation and serialization server API was refactored to reuse serialization libraries between the server and client. The main changes are:

ContentNegotiation is moved from ktor-server-core to a separate ktor-server-content-negotiation artifact.

Serialization libraries are moved from ktor-* to the ktor-serialization-* artifacts also used by the client.

You need to update dependencies for and imports in your application, as shown below.

Dependencies﻿
Subsystem

1.6.x

2.0.0

ContentNegotiation

io.ktor:ktor-server-core

io.ktor:ktor-server-content-negotiation

kotlinx.serialization

io.ktor:ktor-serialization

io.ktor:ktor-serialization-kotlinx-json

Gson

io.ktor:ktor-gson

io.ktor:ktor-serialization-gson

Jackson

io.ktor:ktor-jackson

io.ktor:ktor-serialization-jackson

Imports﻿
Subsystem

1.6.x

2.0.0

kotlinx.serialization

import io.ktor.serialization.*

import io.ktor.serialization.kotlinx.json.*

Gson

import io.ktor.gson.*

import io.ktor.serialization.gson.*

Jackson

import io.ktor.jackson.*

import io.ktor.serialization.jackson.*

Custom converters﻿
Signatures of functions exposed by the ContentConverter interface are changed in the following way:

1.6.x
2.0.0
interface ContentConverter {
    suspend fun serialize(contentType: ContentType, charset: Charset, typeInfo: TypeInfo, value: Any): OutgoingContent?
    suspend fun deserialize(charset: Charset, typeInfo: TypeInfo, content: ByteReadChannel): Any?
}
Testing API﻿
With v2.0.0, the Ktor server uses a new API for testing, which solves various issues described in KTOR-971. The main changes are:

The withTestApplication/withApplication functions are replaced with a new testApplication function.

Inside the testApplication function, you need to use the existing Ktor client instance to make requests to your server and verify the results.

To test specific functionalities (for example, cookies or WebSockets), you need to create a new client instance and install a corresponding plugin.

Let's take a look at several examples of migrating 1.6.x tests to 2.0.0:

Basic server test﻿
In the test below, the handleRequest function is replaced with the client.get request:

1.6.x
2.0.0
@Test
fun testRoot() = testApplication {
    val response = client.get("/")
    assertEquals(HttpStatusCode.OK, response.status)
    assertEquals("Hello, world!", response.bodyAsText())
}
x-www-form-urlencoded﻿
In the test below, the handleRequest function is replaced with the client.post request:

1.6.x
2.0.0
@Test
fun testPost() = testApplication {
    val response = client.post("/signup") {
        header(HttpHeaders.ContentType, ContentType.Application.FormUrlEncoded.toString())
        setBody(listOf("username" to "JetBrains", "email" to "example@jetbrains.com", "password" to "foobar", "confirmation" to "foobar").formUrlEncode())
    }
    assertEquals("The 'JetBrains' account is created", response.bodyAsText())
}
multipart/form-data﻿
To build multipart/form-data in v2.0.0, you need to pass MultiPartFormDataContent to the client's setBody function:

1.6.x
2.0.0
@Test
fun testUpload() = testApplication {
    val boundary = "WebAppBoundary"
    val response = client.post("/upload") {
        setBody(
            MultiPartFormDataContent(
                formData {
                    append("description", "Ktor logo")
                    append("image", File("ktor_logo.png").readBytes(), Headers.build {
                        append(HttpHeaders.ContentType, "image/png")
                        append(HttpHeaders.ContentDisposition, "filename=\"ktor_logo.png\"")
                    })
                },
                boundary,
                ContentType.MultiPart.FormData.withParameter("boundary", boundary)
            )
        )
    }
    assertEquals("Ktor logo is uploaded to 'uploads/ktor_logo.png'", response.bodyAsText())
}
JSON data﻿
In v.1.6.x, you can serialize JSON data using the Json.encodeToString function provided by the kotlinx.serialization library. With v2.0.0, you need to create a new client instance and install the ContentNegotiation plugin that allows serializing/deserializing the content in a specific format:

1.6.x
2.0.0
@Test
fun testPostCustomer() = testApplication {
    val client = createClient {
        install(ContentNegotiation) {
            json()
        }
    }
    val response = client.post("/customer") {
        contentType(ContentType.Application.Json)
        setBody(Customer(3, "Jet", "Brains"))
    }
    assertEquals("Customer stored correctly", response.bodyAsText())
    assertEquals(HttpStatusCode.Created, response.status)
}
Preserve cookies during testing﻿
In v1.6.x, cookiesSession is used to preserve cookies between requests when testing. With v2.0.0, you need to create a new client instance and install the HttpCookies plugin:

1.6.x
2.0.0
@Test
fun testRequests() = testApplication {
    val client = createClient {
        install(HttpCookies)
    }

    val loginResponse = client.get("/login")
    val response1 = client.get("/user")
    assertEquals("Session ID is 123abc. Reload count is 1.", response1.bodyAsText())
    val response2 = client.get("/user")
    assertEquals("Session ID is 123abc. Reload count is 2.", response2.bodyAsText())
    val response3 = client.get("/user")
    assertEquals("Session ID is 123abc. Reload count is 3.", response3.bodyAsText())
    val logoutResponse = client.get("/logout")
    assertEquals("Session doesn't exist or is expired.", logoutResponse.bodyAsText())
}
WebSockets﻿
In the old API, handleWebSocketConversation is used to test WebSocket conversations. With v2.0.0, you can test WebSocket conversations by using the WebSockets plugin provided by the client:

1.6.x
2.0.0
@Test
fun testConversation() {
    testApplication {
        val client = createClient {
            install(WebSockets)
        }

        client.webSocket("/echo") {
            val greetingText = (incoming.receive() as? Frame.Text)?.readText() ?: ""
            assertEquals("Please enter your name", greetingText)

            send(Frame.Text("JetBrains"))
            val responseText = (incoming.receive() as Frame.Text).readText()
            assertEquals("Hi, JetBrains!", responseText)
        }
    }
}
DoubleReceive﻿
With v2.0.0, the DoubleReceive plugin configuration introduces the cacheRawRequest property, which is opposite to receiveEntireContent:

In v1.6.x, the receiveEntireContent property is set to false by default.

In v2.0.0, cacheRawRequest is set to true by default. The receiveEntireContent property is removed.

Forwarded headers﻿
In v2.0.0, the ForwardedHeaderSupport and XForwardedHeaderSupport plugins are renamed to ForwardedHeaders and XForwardedHeaders, respectively.

Caching headers﻿
The options function used to define caching options now accepts the ApplicationCall as a lambda argument in addition to OutgoingContent:

1.6.x
2.0.0
install(CachingHeaders) {
    options { call, outgoingContent ->
        // ...
    }
}
Conditional headers﻿
The version function used to define a list of resource versions now accepts the ApplicationCall as a lambda argument in addition to OutgoingContent:

1.6.x
2.0.0
install(ConditionalHeaders) {
    version { call, outgoingContent ->
        // ...
    }
}
CORS﻿
Several functions used in CORS configuration are renamed:

host-> allowHost

header-> allowHeader

method-> allowMethod

1.6.x
2.0.0
install(CORS) {
    allowHost("0.0.0.0:5000")
    allowHeader(HttpHeaders.ContentType)
    allowMethod(HttpMethod.Options)
}
MicrometerMetrics﻿
In v1.6.x, the baseName property is used to specify the base name (prefix) of Ktor metrics used for monitoring HTTP requests. By default, it equals to ktor.http.server. With v2.0.0, baseName is replaced with metricName whose default value is ktor.http.server.requests.
